<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Buscaminas</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
    }

    table {
      border-collapse: collapse;
      user-select: none;
      touch-action: manipulation;
    }

    td {
      width: 48px;
      height: 48px;
      background: #222;
      border: 1px solid #444;
      color: white;
      font-size: 1.6em;
      text-align: center;
      vertical-align: middle;
    }

    td.revealed {
      background: #444;
    }

    td.flagged {
      background: #1a1a1a;
      color: red;
    }

    td.mine {
      background: red;
    }
  </style>
</head>
<body>
  <h2>Buscaminas</h2>
  <table id="minesweeper"></table>
  <script>
    const rows = 9, cols = 9, mineCount = 9;
    const board = [];
    let gameOver = false;

    function createBoard() {
      const table = document.getElementById('minesweeper');
      table.innerHTML = '';
      gameOver = false;

      // Inicializar tablero
      for (let r = 0; r < rows; r++) {
        const row = [];
        const tr = document.createElement('tr');
        for (let c = 0; c < cols; c++) {
          const cell = {
            mine: false,
            revealed: false,
            flagged: false,
            row: r,
            col: c,
            element: document.createElement('td'),
          };
          row.push(cell);
          tr.appendChild(cell.element);
        }
        board.push(row);
        table.appendChild(tr);
      }

      // Colocar minas
      let placed = 0;
      while (placed < mineCount) {
        const r = Math.floor(Math.random() * rows);
        const c = Math.floor(Math.random() * cols);
        if (!board[r][c].mine) {
          board[r][c].mine = true;
          placed++;
        }
      }

      // Agregar listeners
      board.forEach(row => {
        row.forEach(cell => {
          cell.element.addEventListener('click', () => handleClick(cell));
          cell.element.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            toggleFlag(cell);
          });

          let pressTimer;
          cell.element.addEventListener("touchstart", (e) => {
            pressTimer = setTimeout(() => toggleFlag(cell), 500);
          });

          cell.element.addEventListener("touchend", (e) => {
            clearTimeout(pressTimer);
          });

          cell.element.addEventListener("dblclick", () => doubleClick(cell));
        });
      });
    }

    function handleClick(cell) {
      if (gameOver || cell.revealed || cell.flagged) return;
      if (cell.mine) {
        cell.element.classList.add('mine');
        cell.element.innerText = "ðŸ’£";
        revealAllMines();
        alert("Â¡Perdiste!");
        gameOver = true;
        return;
      }

      revealCell(cell);
      checkWin();
    }

    function toggleFlag(cell) {
      if (cell.revealed || gameOver) return;
      cell.flagged = !cell.flagged;
      cell.element.classList.toggle('flagged');
      cell.element.innerText = cell.flagged ? "ðŸš©" : "";
    }

    function revealCell(cell) {
      if (cell.revealed || cell.flagged) return;
      cell.revealed = true;
      cell.element.classList.add('revealed');
      const minesAround = countMines(cell.row, cell.col);
      if (minesAround > 0) {
        cell.element.innerText = minesAround;
      } else {
        getNeighbors(cell.row, cell.col).forEach(n => revealCell(n));
      }
    }

    function countMines(r, c) {
      return getNeighbors(r, c).filter(n => n.mine).length;
    }

    function getNeighbors(r, c) {
      const neighbors = [];
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
            neighbors.push(board[nr][nc]);
          }
        }
      }
      return neighbors;
    }

    function revealAllMines() {
      board.flat().forEach(cell => {
        if (cell.mine) {
          cell.element.innerText = "ðŸ’£";
          cell.element.classList.add('mine');
        }
      });
    }

    function checkWin() {
      const unrevealed = board.flat().filter(c => !c.revealed);
      if (unrevealed.length === mineCount) {
        alert("Â¡Ganaste!");
        gameOver = true;
      }
    }

    function doubleClick(cell) {
      if (!cell.revealed || gameOver) return;
      const neighbors = getNeighbors(cell.row, cell.col);
      const flagged = neighbors.filter(n => n.flagged).length;
      const minesAround = countMines(cell.row, cell.col);
      if (flagged === minesAround) {
        neighbors.forEach(n => {
          if (!n.revealed && !n.flagged) handleClick(n);
        });
      }
    }

    createBoard();
  </script>
</body>
</html>